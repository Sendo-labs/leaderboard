/**
 * JWT Verification for X Account Linking
 *
 * Verifies JWT tokens generated by the auth-worker to ensure
 * X accounts are legitimately linked to GitHub accounts
 */

import { createLogger } from "@/lib/logger";

const logger = createLogger({
  minLevel: "info",
  nameSegments: ["JWTVerifier"],
});

interface JWTPayload {
  githubUsername: string;
  xUserId: string;
  xUsername: string;
  linkedAt: string;
  exp?: number; // Optional expiration
}

/**
 * Base64 URL decode
 */
function base64UrlDecode(str: string): string {
  // Replace URL-safe characters
  str = str.replace(/-/g, "+").replace(/_/g, "/");

  // Add padding if needed
  while (str.length % 4 !== 0) {
    str += "=";
  }

  return Buffer.from(str, "base64").toString("utf-8");
}

/**
 * Parse JWT without verification (to get payload)
 */
export function parseJWT(token: string): JWTPayload | null {
  try {
    const parts = token.split(".");
    if (parts.length !== 3) {
      logger.error("Invalid JWT format: expected 3 parts");
      return null;
    }

    const payload = JSON.parse(base64UrlDecode(parts[1]));
    return payload;
  } catch (error) {
    logger.error("Failed to parse JWT", {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Verify JWT signature using HMAC-SHA256
 */
export async function verifyJWT(
  token: string,
  secret: string,
): Promise<JWTPayload | null> {
  try {
    const parts = token.split(".");
    if (parts.length !== 3) {
      logger.error("Invalid JWT format");
      return null;
    }

    const [headerB64, payloadB64, signatureB64] = parts;

    // Parse payload
    const payload: JWTPayload = JSON.parse(base64UrlDecode(payloadB64));

    // Check expiration if present
    if (payload.exp && Date.now() >= payload.exp * 1000) {
      logger.warn("JWT has expired", { exp: payload.exp });
      return null;
    }

    // Verify signature
    const encoder = new TextEncoder();
    const data = encoder.encode(`${headerB64}.${payloadB64}`);
    const secretKey = encoder.encode(secret);

    // Import key
    const key = await crypto.subtle.importKey(
      "raw",
      secretKey,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign", "verify"],
    );

    // Compute signature
    const expectedSignatureBuffer = await crypto.subtle.sign("HMAC", key, data);

    // Convert to base64url
    const expectedSignatureB64 = Buffer.from(expectedSignatureBuffer)
      .toString("base64")
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=/g, "");

    // Compare signatures
    if (expectedSignatureB64 !== signatureB64) {
      logger.error("JWT signature verification failed");
      return null;
    }

    return payload;
  } catch (error) {
    logger.error("Error verifying JWT", {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Verify X account linking data
 *
 * Checks:
 * 1. JWT signature is valid
 * 2. GitHub username matches
 * 3. X user ID matches
 * 4. X username matches
 * 5. JWT hasn't expired
 */
export async function verifyXAccountLinking(
  githubUsername: string,
  xUserId: string,
  xUsername: string,
  linkingProof: string,
  secret: string,
): Promise<boolean> {
  // Verify JWT signature and get payload
  const payload = await verifyJWT(linkingProof, secret);

  if (!payload) {
    logger.error("JWT verification failed for", { githubUsername, xUsername });
    return false;
  }

  // Verify all fields match
  if (
    payload.githubUsername !== githubUsername ||
    payload.xUserId !== xUserId ||
    payload.xUsername.toLowerCase() !== xUsername.toLowerCase()
  ) {
    logger.error("JWT payload doesn't match linking data", {
      expected: { githubUsername, xUserId, xUsername },
      actual: payload,
    });
    return false;
  }

  return true;
}

/**
 * Get linking secret from environment
 */
export function getLinkingSecret(): string {
  const secret = process.env.LINKING_SECRET;

  if (!secret) {
    throw new Error(
      "LINKING_SECRET environment variable is required. " +
        "This should match the secret used by the auth-worker.",
    );
  }

  return secret;
}
